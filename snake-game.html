<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Snake - éœ“è™¹è²ªé£Ÿè›‡</title>
  <style>
    /* ===== CSS æ¨£å¼ - Cyberpunk/Retro éœ“è™¹é¢¨æ ¼ ===== */
    
    /* å…¨å±€é‡ç½® */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* é é¢èƒŒæ™¯ - æ·±è‰² */
    body {
      background: #0a0a0f;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: 'Courier New', monospace;
      overflow: hidden;
    }

    /* éŠæˆ²å®¹å™¨ */
    #game-container {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    /* éŠæˆ²æ¨™é¡Œ */
    h1 {
      color: #00ff88;
      font-size: 2.5rem;
      text-shadow: 
        0 0 10px #00ff88,
        0 0 20px #00ff88,
        0 0 40px #00cc6a;
      letter-spacing: 8px;
      animation: titleGlow 2s ease-in-out infinite alternate;
    }

    @keyframes titleGlow {
      from {
        text-shadow: 
          0 0 10px #00ff88,
          0 0 20px #00ff88,
          0 0 40px #00cc6a;
      }
      to {
        text-shadow: 
          0 0 15px #00ff88,
          0 0 30px #00ff88,
          0 0 60px #00cc6a,
          0 0 80px #00ff88;
      }
    }

    /* éŠæˆ²ç•«å¸ƒ - éœ“è™¹é‚Šæ¡† */
    #gameCanvas {
      border: 3px solid #00d4ff;
      box-shadow: 
        0 0 20px #00d4ff,
        inset 0 0 20px rgba(0, 212, 255, 0.1);
      background: #0d0d12;
    }

    /* è¨ˆåˆ†æ¿å€åŸŸ */
    .score-board {
      display: flex;
      justify-content: space-between;
      width: 400px;
      padding: 10px 20px;
      background: rgba(0, 212, 255, 0.1);
      border: 1px solid #00d4ff;
      border-radius: 5px;
    }

    .score-item {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .score-label {
      color: #00d4ff;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .score-value {
      color: #00ff88;
      font-size: 1.5rem;
      font-weight: bold;
      text-shadow: 0 0 10px #00ff88;
      transition: transform 0.1s ease;
    }

    .score-value.bounce {
      animation: scoreBounce 0.3s ease;
    }

    @keyframes scoreBounce {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.3); }
    }

    /* æ“ä½œèªªæ˜ */
    .controls-info {
      color: #666;
      font-size: 0.75rem;
      text-align: center;
      margin-top: 10px;
    }

    .controls-info span {
      color: #ff0080;
    }

    /* éŠæˆ²çµæŸè¦†è“‹å±¤ */
    #gameOverOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 10, 15, 0.95);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 20px;
      z-index: 10;
    }

    #gameOverOverlay.show {
      display: flex;
    }

    .game-over-title {
      color: #ff0080;
      font-size: 2rem;
      text-shadow: 
        0 0 10px #ff0080,
        0 0 20px #ff0080;
      animation: gameOverPulse 1s ease-in-out infinite alternate;
    }

    @keyframes gameOverPulse {
      from { opacity: 0.8; }
      to { opacity: 1; }
    }

    .final-score {
      color: #00ff88;
      font-size: 1.2rem;
    }

    .new-record {
      color: #ffff00;
      font-size: 1rem;
      text-shadow: 0 0 10px #ffff00;
      animation: newRecordFlash 0.5s ease-in-out infinite alternate;
    }

    @keyframes newRecordFlash {
      from { opacity: 0.7; }
      to { opacity: 1; }
    }

    /* æŒ‰éˆ•æ¨£å¼ */
    .restart-btn {
      padding: 15px 40px;
      font-size: 1rem;
      font-family: 'Courier New', monospace;
      background: transparent;
      color: #00d4ff;
      border: 2px solid #00d4ff;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 3px;
      transition: all 0.3s ease;
      margin-top: 20px;
    }

    .restart-btn:hover {
      background: #00d4ff;
      color: #0a0a0f;
      box-shadow: 
        0 0 20px #00d4ff,
        0 0 40px #00d4ff;
    }

    /* æš«åœæç¤º */
    #pauseOverlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #00d4ff;
      font-size: 2rem;
      text-shadow: 0 0 20px #00d4ff;
      display: none;
      z-index: 5;
    }

    #pauseOverlay.show {
      display: block;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <h1>SNAKE</h1>
    
    <div class="score-board">
      <div class="score-item">
        <span class="score-label">åˆ†æ•¸</span>
        <span class="score-value" id="currentScore">0</span>
      </div>
      <div class="score-item">
        <span class="score-label">æœ€é«˜åˆ†</span>
        <span class="score-value" id="highScore">0</span>
      </div>
    </div>

    <canvas id="gameCanvas" width="400" height="400"></canvas>
    
    <div class="controls-info">
      <span>â†‘â†“â†â†’</span> ç§»å‹• &nbsp;|&nbsp; <span>ç©ºæ ¼</span> æš«åœ/ç¹¼çºŒ
    </div>

    <!-- éŠæˆ²çµæŸè¦†è“‹å±¤ -->
    <div id="gameOverOverlay">
      <div class="game-over-title">GAME OVER</div>
      <div class="final-score" id="finalScore">åˆ†æ•¸: 0</div>
      <div class="new-record" id="newRecord" style="display: none;">ğŸ‰ æ–°ç´€éŒ„! ğŸ‰</div>
      <button class="restart-btn" id="restartBtn">å†ç©ä¸€æ¬¡</button>
    </div>

    <!-- æš«åœæç¤º -->
    <div id="pauseOverlay">PAUSED</div>
  </div>

  <script>
    /* ===== JavaScript éŠæˆ²é‚è¼¯ ===== */

    // ===== éŠæˆ²é…ç½® =====
    const CONFIG = {
      GRID_SIZE: 20,           // æ ¼å­å¤§å°
      GRID_COUNT: 20,          // ç¶²æ ¼æ•¸é‡ (20x20)
      INITIAL_SPEED: 150,      // åˆå§‹é€Ÿåº¦ (ms)
      MIN_SPEED: 50,           // æœ€å°é€Ÿåº¦ (æœ€å¿«)
      SPEED_DECREASE: 5,        // æ¯åƒä¸€å€‹é£Ÿç‰©æ¸›å°‘çš„é€Ÿåº¦
      POINTS_PER_FOOD: 10,     // æ¯å€‹é£Ÿç‰©çš„åˆ†æ•¸
      STORAGE_KEY: 'snakeHighScore'  // localStorage éµå
    };

    // ===== éŠæˆ²ç‹€æ…‹ =====
    const game = {
      canvas: null,
      ctx: null,
      snake: [],               // è›‡çš„èº«é«”é™£åˆ—
      direction: { x: 1, y: 0 }, // ç•¶å‰æ–¹å‘
      nextDirection: { x: 1, y: 0 }, // ä¸‹ä¸€å€‹æ–¹å‘ (ç·©è¡)
      food: { x: 0, y: 0 },    // é£Ÿç‰©ä½ç½®
      score: 0,                // ç•¶å‰åˆ†æ•¸
      highScore: 0,            // æœ€é«˜åˆ†æ•¸
      speed: CONFIG.INITIAL_SPEED,
      isRunning: false,        // éŠæˆ²æ˜¯å¦é‹è¡Œä¸­
      isPaused: false,         // æ˜¯å¦æš«åœ
      lastFrameTime: 0,        // ä¸Šä¸€å¹€æ™‚é–“
      foodFlashPhase: 0        // é£Ÿç‰©é–ƒçˆå‹•ç•«ç›¸ä½
    };

    // ===== DOM å…ƒç´  =====
    const elements = {
      canvas: document.getElementById('gameCanvas'),
      currentScore: document.getElementById('currentScore'),
      highScore: document.getElementById('highScore'),
      gameOverOverlay: document.getElementById('gameOverOverlay'),
      finalScore: document.getElementById('finalScore'),
      newRecord: document.getElementById('newRecord'),
      restartBtn: document.getElementById('restartBtn'),
      pauseOverlay: document.getElementById('pauseOverlay')
    };

    // ===== åˆå§‹åŒ–éŠæˆ² =====
    function init() {
      // ç²å– Canvas ä¸Šä¸‹æ–‡
      game.canvas = elements.canvas;
      game.ctx = game.canvas.getContext('2d');

      // è¼‰å…¥æœ€é«˜åˆ†
      loadHighScore();

      // ç¶å®šéµç›¤äº‹ä»¶
      document.addEventListener('keydown', handleKeyDown);

      // ç¶å®šé‡æ–°é–‹å§‹æŒ‰éˆ•
      elements.restartBtn.addEventListener('click', startGame);

      // é–‹å§‹éŠæˆ²
      startGame();
    }

    // ===== é–‹å§‹éŠæˆ² =====
    function startGame() {
      // é‡ç½®éŠæˆ²ç‹€æ…‹
      game.snake = [
        { x: 10, y: 10 },  // è›‡é ­
        { x: 9, y: 10 },
        { x: 8, y: 10 }   // è›‡å°¾
      ];
      game.direction = { x: 1, y: 0 };
      game.nextDirection = { x: 1, y: 0 };
      game.score = 0;
      game.speed = CONFIG.INITIAL_SPEED;
      game.isRunning = true;
      game.isPaused = false;

      // éš±è—éŠæˆ²çµæŸç•«é¢
      elements.gameOverOverlay.classList.remove('show');
      elements.pauseOverlay.classList.remove('show');

      // æ›´æ–°åˆ†æ•¸é¡¯ç¤º
      updateScoreDisplay();

      // ç”Ÿæˆç¬¬ä¸€å€‹é£Ÿç‰©
      spawnFood();

      // é–‹å§‹éŠæˆ²å¾ªç’°
      game.lastFrameTime = performance.now();
      requestAnimationFrame(gameLoop);
    }

    // ===== éŠæˆ²ä¸»å¾ªç’° =====
    function gameLoop(currentTime) {
      if (!game.isRunning) return;

      // è¨ˆç®—æ™‚é–“å·®
      const deltaTime = currentTime - game.lastFrameTime;

      if (!game.isPaused) {
        // æª¢æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°éŠæˆ²ç‹€æ…‹ (åŸºæ–¼é€Ÿåº¦)
        if (deltaTime >= game.speed) {
          update();
          game.lastFrameTime = currentTime;
        }

        // æ›´æ–°é£Ÿç‰©é–ƒçˆå‹•ç•«
        game.foodFlashPhase = (game.foodFlashPhase + 0.1) % (Math.PI * 2);
      }

      // æ¸²æŸ“éŠæˆ²
      render();

      // ç¹¼çºŒå¾ªç’°
      requestAnimationFrame(gameLoop);
    }

    // ===== æ›´æ–°éŠæˆ²ç‹€æ…‹ =====
    function update() {
      // æ›´æ–°æ–¹å‘
      game.direction = { ...game.nextDirection };

      // è¨ˆç®—æ–°è›‡é ­ä½ç½®
      const head = game.snake[0];
      const newHead = {
        x: head.x + game.direction.x,
        y: head.y + game.direction.y
      };

      // æª¢æŸ¥ç¢°æ’é‚Šç•Œ
      if (newHead.x < 0 || newHead.x >= CONFIG.GRID_COUNT ||
          newHead.y < 0 || newHead.y >= CONFIG.GRID_COUNT) {
        gameOver();
        return;
      }

      // æª¢æŸ¥ç¢°æ’è‡ªå·±
      for (let segment of game.snake) {
        if (newHead.x === segment.x && newHead.y === segment.y) {
          gameOver();
          return;
        }
      }

      // æ·»åŠ æ–°è›‡é ­
      game.snake.unshift(newHead);

      // æª¢æŸ¥æ˜¯å¦åƒåˆ°é£Ÿç‰©
      if (newHead.x === game.food.x && newHead.y === game.food.y) {
        // åƒåˆ°é£Ÿç‰©
        game.score += CONFIG.POINTS_PER_FOOD;
        
        // å¢åŠ é€Ÿåº¦ (é›£åº¦)
        game.speed = Math.max(
          CONFIG.MIN_SPEED,
          CONFIG.INITIAL_SPEED - Math.floor(game.score / CONFIG.POINTS_PER_FOOD) * CONFIG.SPEED_DECREASE
        );

        // æ›´æ–°åˆ†æ•¸é¡¯ç¤º
        updateScoreDisplay();

        // ç”Ÿæˆæ–°é£Ÿç‰©
        spawnFood();
      } else {
        // æ²’åƒåˆ°é£Ÿç‰©ï¼Œç§»é™¤è›‡å°¾
        game.snake.pop();
      }
    }

    // ===== æ¸²æŸ“éŠæˆ² =====
    function render() {
      const ctx = game.ctx;
      const gridSize = CONFIG.GRID_SIZE;

      // æ¸…ç©ºç•«å¸ƒ
      ctx.fillStyle = '#0d0d12';
      ctx.fillRect(0, 0, game.canvas.width, game.canvas.height);

      // ç¹ªè£½ç¶²æ ¼ (å¯é¸ï¼Œå¢åŠ è¦–è¦ºæ•ˆæœ)
      ctx.strokeStyle = 'rgba(0, 212, 255, 0.05)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= CONFIG.GRID_COUNT; i++) {
        ctx.beginPath();
        ctx.moveTo(i * gridSize, 0);
        ctx.lineTo(i * gridSize, CONFIG.GRID_COUNT * gridSize);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i * gridSize);
        ctx.lineTo(CONFIG.GRID_COUNT * gridSize, i * gridSize);
        ctx.stroke();
      }

      // ç¹ªè£½é£Ÿç‰© (å¸¶é–ƒçˆæ•ˆæœ)
      drawFood();

      // ç¹ªè£½è›‡ (å¸¶æ¼¸è®Šæ•ˆæœ)
      drawSnake();
    }

    // ===== ç¹ªè£½é£Ÿç‰© =====
    function drawFood() {
      const ctx = game.ctx;
      const gridSize = CONFIG.GRID_SIZE;
      const x = game.food.x * gridSize + gridSize / 2;
      const y = game.food.y * gridSize + gridSize / 2;

      // è¨ˆç®—é–ƒçˆæ•ˆæœ
      const flash = Math.sin(game.foodFlashPhase) * 0.3 + 0.7;
      const size = gridSize / 2 - 2;

      // é£Ÿç‰©ç™¼å…‰æ•ˆæœ
      ctx.shadowColor = '#ff0080';
      ctx.shadowBlur = 15 * flash;

      // ç¹ªè£½é£Ÿç‰© (åœ“å½¢)
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 0, 128, ${flash})`;
      ctx.fill();

      // å…§éƒ¨äº®é»
      ctx.beginPath();
      ctx.arc(x - 2, y - 2, size * 0.3, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 255, 255, ${flash * 0.8})`;
      ctx.fill();

      // é‡ç½®é™°å½±
      ctx.shadowBlur = 0;
    }

    // ===== ç¹ªè£½è›‡ =====
    function drawSnake() {
      const ctx = game.ctx;
      const gridSize = CONFIG.GRID_SIZE;

      // ç¹ªè£½è›‡èº«
      game.snake.forEach((segment, index) => {
        const x = segment.x * gridSize;
        const y = segment.y * gridSize;
        const padding = 1;

        // è¨ˆç®—æ¼¸è®Šé¡è‰² (é ­éƒ¨è¼ƒäº®ï¼Œå°¾éƒ¨è¼ƒæš—)
        const ratio = 1 - (index / game.snake.length) * 0.5;
        const r = Math.floor(0 + ratio * 0);
        const g = Math.floor(255 * ratio);
        const b = Math.floor(136 * ratio);

        // è›‡èº«ç™¼å…‰æ•ˆæœ
        ctx.shadowColor = `rgb(${r}, ${g}, ${b})`;
        ctx.shadowBlur = index === 0 ? 15 : 8;

        // ç¹ªè£½åœ“è§’çŸ©å½¢
        const radius = 4;
        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        
        // ä½¿ç”¨è·¯å¾‘ç¹ªè£½åœ“è§’çŸ©å½¢
        ctx.beginPath();
        ctx.roundRect(
          x + padding,
          y + padding,
          gridSize - padding * 2,
          gridSize - padding * 2,
          radius
        );
        ctx.fill();

        // è›‡é ­ç‰¹åˆ¥æ¨™è¨˜
        if (index === 0) {
          ctx.fillStyle = '#ffffff';
          const eyeSize = 3;
          const eyeOffset = 5;
          
          // çœ¼ç›ä½ç½®æ ¹æ“šæ–¹å‘èª¿æ•´
          let eye1X, eye1Y, eye2X, eye2Y;
          
          if (game.direction.x === 1) { // å‘å³
            eye1X = x + gridSize - eyeOffset - eyeSize;
            eye1Y = y + eyeOffset;
            eye2X = x + gridSize - eyeOffset - eyeSize;
            eye2Y = y + gridSize - eyeOffset - eyeSize;
          } else if (game.direction.x === -1) { // å‘å·¦
            eye1X = x + eyeOffset;
            eye1Y = y + eyeOffset;
            eye2X = x + eyeOffset;
            eye2Y = y + gridSize - eyeOffset - eyeSize;
          } else if (game.direction.y === -1) { // å‘ä¸Š
            eye1X = x + eyeOffset;
            eye1Y = y + eyeOffset;
            eye2X = x + gridSize - eyeOffset - eyeSize;
            eye2Y = y + eyeOffset;
          } else { // å‘ä¸‹
            eye1X = x + eyeOffset;
            eye1Y = y + gridSize - eyeOffset - eyeSize;
            eye2X = x + gridSize - eyeOffset - eyeSize;
            eye2Y = y + gridSize - eyeOffset - eyeSize;
          }

          ctx.beginPath();
          ctx.arc(eye1X, eye1Y, eyeSize, 0, Math.PI * 2);
          ctx.arc(eye2X, eye2Y, eyeSize, 0, Math.PI * 2);
          ctx.fill();
        }
      });

      // é‡ç½®é™°å½±
      ctx.shadowBlur = 0;
    }

    // ===== ç”Ÿæˆé£Ÿç‰© =====
    function spawnFood() {
      let validPosition = false;
      
      while (!validPosition) {
        // éš¨æ©Ÿç”Ÿæˆä½ç½®
        game.food = {
          x: Math.floor(Math.random() * CONFIG.GRID_COUNT),
          y: Math.floor(Math.random() * CONFIG.GRID_COUNT)
        };

        // ç¢ºä¿é£Ÿç‰©ä¸æœƒç”Ÿæˆåœ¨è›‡èº«ä¸Š
        validPosition = true;
        for (let segment of game.snake) {
          if (game.food.x === segment.x && game.food.y === segment.y) {
            validPosition = false;
            break;
          }
        }
      }
    }

    // ===== è™•ç†éµç›¤è¼¸å…¥ =====
    function handleKeyDown(event) {
      // é˜»æ­¢æ–¹å‘éµå’Œç©ºæ ¼çš„é»˜èªè¡Œç‚º
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(event.key)) {
        event.preventDefault();
      }

      // è™•ç†æ–¹å‘éµ
      switch (event.key) {
        case 'ArrowUp':
          if (game.direction.y !== 1) {
            game.nextDirection = { x: 0, y: -1 };
          }
          break;
        case 'ArrowDown':
          if (game.direction.y !== -1) {
            game.nextDirection = { x: 0, y: 1 };
          }
          break;
        case 'ArrowLeft':
          if (game.direction.x !== 1) {
            game.nextDirection = { x: -1, y: 0 };
          }
          break;
        case 'ArrowRight':
          if (game.direction.x !== -1) {
            game.nextDirection = { x: 1, y: 0 };
          }
          break;
        case ' ':  // ç©ºæ ¼éµ
          togglePause();
          break;
      }
    }

    // ===== åˆ‡æ›æš«åœç‹€æ…‹ =====
    function togglePause() {
      if (!game.isRunning) return;

      game.isPaused = !game.isPaused;
      
      if (game.isPaused) {
        elements.pauseOverlay.classList.add('show');
      } else {
        elements.pauseOverlay.classList.remove('show');
        // é‡ç½®ä¸Šä¸€å¹€æ™‚é–“ï¼Œé˜²æ­¢æš«åœå¾Œè·³é
        game.lastFrameTime = performance.now();
      }
    }

    // ===== æ›´æ–°åˆ†æ•¸é¡¯ç¤º =====
    function updateScoreDisplay() {
      elements.currentScore.textContent = game.score;
      
      // æ·»åŠ å½ˆè·³å‹•ç•«
      elements.currentScore.classList.add('bounce');
      setTimeout(() => {
        elements.currentScore.classList.remove('bounce');
      }, 300);
    }

    // ===== éŠæˆ²çµæŸ =====
    function gameOver() {
      game.isRunning = false;

      // æª¢æŸ¥æ˜¯å¦æ–°ç´€éŒ„
      let isNewRecord = false;
      if (game.score > game.highScore) {
        game.highScore = game.score;
        saveHighScore();
        elements.highScore.textContent = game.highScore;
        isNewRecord = true;
      }

      // é¡¯ç¤ºéŠæˆ²çµæŸç•«é¢
      elements.finalScore.textContent = `åˆ†æ•¸: ${game.score}`;
      elements.newRecord.style.display = isNewRecord ? 'block' : 'none';
      elements.gameOverOverlay.classList.add('show');
    }

    // ===== è¼‰å…¥æœ€é«˜åˆ† =====
    function loadHighScore() {
      const saved = localStorage.getItem(CONFIG.STORAGE_KEY);
      if (saved) {
        game.highScore = parseInt(saved, 10);
        elements.highScore.textContent = game.highScore;
      }
    }

    // ===== å„²å­˜æœ€é«˜åˆ† =====
    function saveHighScore() {
      localStorage.setItem(CONFIG.STORAGE_KEY, game.highScore.toString());
    }

    // ===== å•Ÿå‹•éŠæˆ² =====
    init();
  </script>
</body>
</html>
